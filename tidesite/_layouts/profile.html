<!DOCTYPE html>
<html lang="{{ page.lang | default: site.lang | default: "en" }}">

  {%- include head.html -%}

  <body>

    {%- include header.html -%}

    <main class="page-content" aria-label="Content">
      <div class="wrapper">



<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">{{ page.title | escape }}</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="{{ page.date | date_to_xmlschema }}" itemprop="datePublished">
        {%- assign date_format = site.minima.date_format | default: "%b %-d, %Y" -%}
        {{ page.date | date: date_format }}
      </time>
      {%- if page.author -%}
        • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">{{ page.author }}</span></span>
      {%- endif -%}</p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">

<script src="https://www.puck-js.com/puck.js"></script>
<script src="{{ site.baseurl }}/assets/tide-predictor.js"></script>
<!-- <script src="{{ site.baseurl }}/assets/myscript.js"></script> -->
<script>
    function sendHighLow(hl, lat0){
        console.log("Tides : ");
        console.log(hl);
        console.log("**********");
        //myString = JSON.stringify(hl);
        filestr = []
        for (key in hl){
            entry = hl[key];
            line = [entry['time'].getTime(), Math.trunc(entry['level']-lat0), entry['high']].join(",");
            filestr.push(line)
        }
        myString = "\""+filestr.join(";")+"\"";
        //console.log(ble)
        //console.log(myString);
        cmd="require(\"Storage\").write(\"tides.data.csv\","+myString+");\n";
        console.log(cmd);
        Puck.connect(function(c) {
            if (!c) {
                alert("Couldn't connect!");
                return;
            }
            c.write("reset();\n", function() {
                // Wait for it to reset itself
                setTimeout(function() {
                    // Now tell it to write data on the current light
                    // level to Bluetooth 10 times a second. Also
                    // ensure that when disconnected, Puck.js resets
                    // so the setInterval doesn't keep draining
                    // battery.
                    c.write(cmd,
                            function() { console.log("Ready..."); });
                }, 1500);
            });
        });
        //Puck.write(cmd);
    };


// function writeCurrentTable(hl_u, hl_v){
//     const monthNames = ["Janúar", "Febrúar", "Mars", "Apríl", "Maí", "Júní",
//                         "Júlí", "Águst", "September", "Október", "Nóvember", "Desember"
//                        ];

//     hl.forEach(level => {
//         const tableRow = document.createElement('tr')
//         sealevelm = ( (level.level - lat0)/100).toFixed(2);
//         dt = level.time;
//         console.log(" time : " + dt);
//         lbl = "";
//         if (level.high)
//         {
//             lbl = "Flóð";
//         } else
//         {
//             lbl = "Fjara";
//         }
//         console.log("date : " + dt.getDate());
//         dtfmt = dt.getFullYear()+' '+dt.getDate()+' '+monthNames[dt.getMonth()]+' '+dt.getHours()+':'+dt.getMinutes();
//         tableRow.innerHTML = `
//               <td>${dtfmt}</td>
//               <td>${lbl}</td>
//               <td>${sealevelm}m</td>
//             `
//         document.getElementById('tides').appendChild(tableRow)
//     })
// };


function writeToTable(hl, lat0){
    const monthNames = ["Janúar", "Febrúar", "Mars", "Apríl", "Maí", "Júní",
                        "Júlí", "Águst", "September", "Október", "Nóvember", "Desember"
                       ];

    hl.forEach(level => {
        const tableRow = document.createElement('tr')
        sealevelm = ( (level.level - lat0)/100).toFixed(2);
        dt = level.time;
        console.log(" time : " + dt);
        lbl = "";
        if (level.high)
        {
            lbl = "Flóð";
        } else
        {
            lbl = "Fjara";
        }
        console.log("date : " + dt.getDate());
        dtfmt = dt.getFullYear()+' '+dt.getDate()+' '+monthNames[dt.getMonth()]+' '+dt.getHours()+':'+dt.getMinutes();
        tableRow.innerHTML = `
              <td>${dtfmt}</td>
              <td>${lbl}</td>
              <td>${sealevelm}m</td>
            `
        document.getElementById('tides').appendChild(tableRow)
    })
};

function makeCalc() {
    console.log("make calculations");
    const harmonicsOptions = {};
    const jsonfile = "{{ site.url }}/assets/{{page.datafile}}.json";
    fetch(jsonfile)
    .then(response =>
        {return response.json()})
    .then(harmonics => {
        lat0=0
        // Lowest astronomical tide
        for (key in harmonics){
            if ("amplitude" in harmonics[key]){
                lat0 = lat0 - harmonics[key]['amplitude'];
            }
        }
        console.log("LAT "+lat0)
        const now = new Date();
        const startDate = new Date(now.getTime() - (2*24*60*60*1000));
        const endDate = new Date(now.getTime() + (30*24*60*60*1000));
        console.log("Start time : " + startDate);
        console.log("End time : " + endDate);
        let pred = tidePredictor(harmonics, {phaseKey: 'phase',})
        var highLow = pred.getExtremesPrediction({
            start: startDate,
            end: endDate,
            labels: {
                //optional human-readable labels
                high: 'High tide',
                low: 'Low tide',
            },
        });
        // sendHighLow(highLow, lat0);
        // writeToTable(highLow, lat0);
    });

    function calcCurr(harmonics) {
        // harmonics = response.json();
        // console.log("harmonics "+harmonics);
        let depth=harmonics.shift();
        console.log("removed :"+JSON.stringify(depth, null, 4));
        const now = new Date();
        // const startDate = new Date(now.getTime() - (2*24*60*60*1000));
        // const endDate = new Date(now.getTime() + (30*24*60*60*1000));
        const startDate = new Date('March 13, 2022 13:00:00');
        const endDate = new Date(startDate.getTime() + (30*24*60*60*1000));
        console.log("Start time : " + startDate);
        console.log("End time : " + endDate);
        let pred = tidePredictor(harmonics, {phaseKey: 'phase', timeFidelity: 10*60*60})
        // var highLow = pred.getExtremesPrediction({
        return [pred.getTimelinePrediction({
            start: startDate,
            end: endDate,
            timeFidelity: 10*60*60
        }), depth];
        // sendHighLow(highLow, lat0);
    };

    const jsonfile_u = "{{ site.url }}/assets/{{page.datafile}}_u.json";
    const jsonfile_v = "{{ site.url }}/assets/{{page.datafile}}_v.json";
    var p_fetchu = fetch(jsonfile_u).then(response =>
        {return response.json()});
    var p_fetchv = fetch(jsonfile_v).then(response =>
        {return response.json()});
    var p_curru = p_fetchu.then(calcCurr);
    var p_currv = p_fetchv.then(calcCurr);

    Promise.all([p_curru, p_currv]).then(function([c_u_obj, c_v_obj]) {
        // write_to_table
        const monthNames = ["Janúar", "Febrúar", "Mars", "Apríl", "Maí", "Júní",
                            "Júlí", "Águst", "September", "Október", "Nóvember", "Desember"
                           ];
        console.log("all tide current values")
        c_v = c_v_obj[0]
        c_u = c_u_obj[0]
        depth_v = c_v_obj[1].depth
        depth_u = c_u_obj[1].depth
        console.log("depths " + depth_v+ " "+depth_u)
        c_v.forEach(function (value, i) {
            dt = value.time;
            console.log("Minutes " + dt.getMinutes());
            if(dt.getMinutes()==0){
            var currspeed = Math.sqrt((value.level/100/100/depth_v)**2 + (c_u[i].level/100/100/depth_u)**2)*3.6;

            console.log('entry %d: %s, %s', i, currspeed, value.level/100/100, c_u[i].level/100/100);
            const tableRow = document.createElement('tr')
            console.log(" time : " + dt);
            console.log("date : " + dt.getDate());
            dtfmt = dt.getFullYear()+' '+dt.getDate()+' '+monthNames[dt.getMonth()]+' '+dt.getHours()+':'+dt.getMinutes();
            tableRow.innerHTML = `
              <td>${dtfmt}</td>
              <td>current</td>
              <td>${(value.level/100/100).toFixed(2)}</td>
              <td>${(c_u[i].level/100/100).toFixed(2)}</td>
              <td>${(100*value.level/100/100/depth_v).toFixed(2)}</td>
              <td>${(100*c_u[i].level/100/100/depth_u).toFixed(2)}</td>
              <td>${currspeed}kn</td>
            `
            document.getElementById('tides').appendChild(tableRow)
            }
    });
    });
        // more processing
        // return // something using both resultA and resultB
    // });


    // .then(response =>
    //     {return response.json()})
        // .then(
    // console.log("Promise"+p)
    // var current_u = Promise.resolve(Promise.resolve(Promise.resolve(p)));
    // console.log("highlow prediction" + current_u)
    // writeToTable(current_u, 0);
}
</script>


<!-- <button onclick="Puck.write('LED1.set();\n');">LED On!</button>
 <button onclick="Puck.write('LED1.reset();\n');">!</button> -->
<button onclick="makeCalc();">Reikna sjávarföll</button>

{% leaflet_map { "center" : [{{page.latitude}}, {{page.longitude}}],
    "zoom" : 10,
    "providerBasemap": "OpenTopoMap" } %}
    {% leaflet_marker {"latitude" : {{page.latitude}},
                       "longitude" : {{page.longitude}},
		       "popupContent": "{{page.sitename}}" } %} 
{% endleaflet_map %}
  </div>
<table class="table">
  <thead>
    <tr>
      <th>Tími</th>
      <th>Flóð/Fjara</th>
      <th>Sjávarhæð (metrar)</th>
    </tr>
    <tbody id="tides">

    </tbody>
  </thead>
</table>

  {%- if site.disqus.shortname -%}
    {%- include disqus_comments.html -%}
  {%- endif -%}

  <a class="u-url" href="{{ page.url | relative_url }}" hidden></a>
</article>

      </div>
    </main>

    {%- include footer.html -%}

  </body>

</html>

